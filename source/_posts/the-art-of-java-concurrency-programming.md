---
title: the-art-of-java-concurrency-programming
date: 2020-12-27 00:48:37
tags:
- 并发编程 
categories:
- 并发编程
---

# 第1章 并发编程的挑战

上下文切换的问题

线程有创建和上下文切换的开销，如何解决？

减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。

死锁的问题

现在我们介绍避免死锁的几个常见方法。
·避免一个线程同时获取多个锁。

·避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。

·尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。

·对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

以及受限于硬件和软件的资源限制问题

对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让
程序在多机上运行

多使用JDK并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化，均可解决了本章提到的几个挑战

# 第2章 Java并发机制的底层实现原理

## 2.1 volatile的应用

有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，
Lock前缀的指令在多核处理器下会引发了两件事情[1]。
1）将当前处理器缓存行的数据写回到系统内存。
2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

## 2.2 synchronized的实现原理与应用

先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现
为以下3种形式。
·对于普通同步方法，锁是当前实例对象。
·对于静态同步方法，锁是当前类的Class对象。
·对于同步方法块，锁是Synchonized括号里配置的对象

JVM基于进入和退出Monitor对
象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter
和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有
详细说明。但是，方法的同步同样可以使用这两个指令来实现

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结
束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有
一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter
指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在
Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状
态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏
向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高
获得锁和释放锁的效率，下文会详细分析。

## 2.3 原子操作的实现原理

在Java中可以通过锁和循环CAS的方式来实现原子操作。
JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的
CAS实现原子操作的三大问题
ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。

# 第3章 Java内存模型

Java的并发采用的是共享内存模型

